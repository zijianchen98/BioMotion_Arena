
"""
A Python program that displays a point‐light biological motion animation of a heavy, “sad” man walking.
The animation uses exactly 15 white point‐lights on a solid black background.
The 15 points represent major joints of a slumped, heavy–bodied man:
  0: Head
  1: Left Shoulder
  2: Right Shoulder
  3: Left Elbow
  4: Right Elbow
  5: Left Hand
  6: Right Hand
  7: Upper Torso
  8: Lower Torso
  9: Left Hip
 10: Right Hip
 11: Left Knee
 12: Right Knee
 13: Left Ankle
 14: Right Ankle

The walking motion is generated by applying phase‐shifted sinusoidal oscillations to the limbs,
combined with a slow forward translation and a slight vertical “bobbing” of the torso and head.
The movement is designed to feel biomechanically plausible – slow, heavy, and realistic.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Define base (rest) coordinates for each joint.
# (x, y) coordinates. The units are arbitrary.
# The figure is drawn standing upright;
# Assume y=0 at the ground (ankle level).
#
# The heavy, “sad” posture is reflected by a slightly drooped upper body.
base_points = np.array([
    [  0, 180],  # 0: Head
    [ -20, 160],  # 1: Left Shoulder
    [  20, 160],  # 2: Right Shoulder
    [ -35, 140],  # 3: Left Elbow
    [  35, 140],  # 4: Right Elbow
    [ -40, 120],  # 5: Left Hand
    [  40, 120],  # 6: Right Hand
    [   0, 150],  # 7: Upper Torso (near shoulders but slightly below)
    [   0, 110],  # 8: Lower Torso (near stomach)
    [ -15,  80],  # 9: Left Hip
    [  15,  80],  #10: Right Hip
    [ -15,  40],  #11: Left Knee
    [  15,  40],  #12: Right Knee
    [ -15,   0],  #13: Left Ankle
    [  15,   0]   #14: Right Ankle
], dtype=float)

# Parameters for animation timing and motion amplitudes.
period = 2.0        # period of one walking cycle [seconds]
fps = 30            # frames per second
dt = 1.0 / fps      # time per frame [sec]
total_time = 10     # total animation time [sec]
n_frames = int(total_time * fps)

# Speed of forward translation
translation_speed = 20  # units per second

# Define amplitude of oscillation for limbs.
leg_lift = 8      # vertical lift for knee/ankle motion
arm_swing = 6     # horizontal swing amplitude for the arms
torso_bob = 3     # vertical bobbing amplitude for the torso and head

def compute_joint_positions(t):
    """
    Compute the position of each joint at time t in seconds.
    Returns an array (15,2) with (x,y) positions.
    """
    # Compute phase of walking cycle (0 to 2*pi).
    phase = 2 * np.pi * (t / period)
    
    # Start with a copy of the base positions.
    pts = base_points.copy()
    
    # Global horizontal translation: the whole figure is walking to the right.
    trans_x = translation_speed * t
    pts[:, 0] += trans_x

    # Apply torso vertical bobbing (to points: head (0), upper torso (7), lower torso (8))
    bob_offset = torso_bob * np.sin(phase)
    for i in [0, 7, 8]:
        pts[i, 1] += bob_offset

    # Define leg movement.
    # Left leg: joints 9 (hip), 11 (knee), 13 (ankle)
    # Right leg: joints 10 (hip), 12 (knee), 14 (ankle)
    # We simulate lifting of the knee and ankle with a cosine profile.
    # Use phase modulation: left leg with phase, right leg with phase shifted by pi.
    left_leg_offset = leg_lift * np.maximum(0, np.sin(phase))
    right_leg_offset = leg_lift * np.maximum(0, np.sin(phase + np.pi))
    
    # For a heavy man, the limb motion is less pronounced and more “stiff”.
    # Only lift the knee and ankle vertically.
    # Left Knee and Ankle:
    for i in [11, 13]:
        pts[i, 1] += left_leg_offset
    # Right Knee and Ankle:
    for i in [12, 14]:
        pts[i, 1] += right_leg_offset

    # Also add a small horizontal push for the stepping foot.
    # If a foot is in the air, it moves slightly forward relative to the hip.
    left_foot_push = 3 * np.maximum(0, np.sin(phase))
    right_foot_push = 3 * np.maximum(0, np.sin(phase + np.pi))
    pts[13,0] += left_foot_push
    pts[14,0] += right_foot_push

    # Arm movement.
    # Left arm (shoulder 1, elbow 3, hand 5) swings opposite to the leg on that side.
    # So left arm swings with sin(phase+pi) and right arm with sin(phase).
    left_arm_offset = arm_swing * np.sin(phase + np.pi)
    right_arm_offset = arm_swing * np.sin(phase)
    for i in [1, 3, 5]:
        pts[i, 0] += left_arm_offset
    for i in [2, 4, 6]:
        pts[i, 0] += right_arm_offset

    # Additionally, add a slight vertical offset to the forearms/hands to mimic arm flexion.
    arm_vertical = 2 * np.sin(phase)
    pts[5, 1] += arm_vertical  # left hand
    pts[6, 1] += arm_vertical  # right hand

    # For a heavy, slumped figure add a slight downward tilt to the shoulders and head.
    slump = 1.5  # constant additional slump offset
    for i in [0, 1, 2]:
        pts[i, 1] -= slump

    return pts

# Set up the figure.
fig, ax = plt.subplots()
fig.patch.set_facecolor('black')
ax.set_facecolor('black')
ax.set_aspect('equal')
ax.axis('off')  # no axes shown

# Determine plot limits – update dynamically based on expected movement.
x_margin = 50
y_margin = 20
# Set initial limits based on starting positions in base_points.
x0 = base_points[:,0].min()
x1 = base_points[:,0].max()
y0 = 0  # ankles level
y1 = base_points[:,1].max() + 20
ax.set_xlim(x0-20, x1 + translation_speed * total_time + x_margin)
ax.set_ylim(y0-10, y1 + y_margin)

# Create a scatter plot for the 15 points.
scat = ax.scatter([], [], s=80, c='white')

def init():
    # Initialization function for FuncAnimation.
    scat.set_offsets([])
    return scat,

def update(frame):
    t = frame * dt
    pts = compute_joint_positions(t)
    scat.set_offsets(pts)
    return scat,

anim = FuncAnimation(fig, update, frames=n_frames, init_func=init,
                     interval=1000/fps, blit=True)

plt.show()
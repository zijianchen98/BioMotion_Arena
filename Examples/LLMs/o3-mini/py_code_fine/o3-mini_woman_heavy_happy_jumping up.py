
"""
This program shows an animation of a happy heavy woman jumping.
The animation draws 15 white “point‐lights” (representing key body joints)
on a solid black background. The motion is generated by smoothly interpolating
between a squat (pre‐jump/landing) pose and a full-extension (peak jump) pose.
The resulting movement is biomechanically plausible and appears natural.
Press the window close button to exit.
"""

import sys, math, pygame, time

# Initialize Pygame
pygame.init()
screen_width, screen_height = 600, 400
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption("Biological Motion: Happy Heavy Woman Jumping")
clock = pygame.time.Clock()

# Define base skeleton: 15 key markers
# Coordinates are relative positions.
# Order: 0: Head
#        1: Left Shoulder, 2: Right Shoulder
#        3: Left Elbow,    4: Right Elbow
#        5: Left Hand,     6: Right Hand
#        7: Spine,        8: Pelvis
#        9: Left Hip,    10: Right Hip
#       11: Left Knee,   12: Right Knee
#       13: Left Ankle,  14: Right Ankle
base_skel = [
    (0, -100),    # Head
    (-20, -80),   # Left Shoulder
    (20, -80),    # Right Shoulder
    (-35, -60),   # Left Elbow
    (35, -60),    # Right Elbow
    (-40, -40),   # Left Hand
    (40, -40),    # Right Hand
    (0, -60),     # Spine
    (0, -40),     # Pelvis
    (-15, -30),   # Left Hip
    (15, -30),    # Right Hip
    (-15, 0),     # Left Knee
    (15, 0),      # Right Knee
    (-15, 30),    # Left Ankle
    (15, 30)      # Right Ankle
]

# Two key poses are defined as modifications ("deltas") to the base skeleton's y-coordinates.
# They simulate: squat (pose at start/landing) and full extension (peak jump).
# For each marker, the delta value is added to its base y coordinate.
delta_squat = [20, 15, 15, 10, 10, 10, 10, 15, 20, 20, 20, -10, -10, 0, 0]   # p = 0 (and p = 1)
delta_peak = [-10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 10, 10]             # p = 0.5

# Animation parameters
period = 2.0  # seconds per cycle
jump_height = 60  # vertical jump displacement in pixels (peak jump offset)

# Screen placement offsets so that the figure appears in the proper location.
center_x = screen_width // 2
# We want the pelvis (base y = -40) to be around y ~ 250 when in "neutral" posture.
offset_y = 290

def get_interpolated_deltas(p):
    """
    For a given progress p in [0, 1] in the cycle, compute the interpolated deltas for each marker.
    For 0 <= p <= 0.5, we interpolate from squat (p=0) to peak (p=0.5).
    For 0.5 < p <= 1, we interpolate from peak to squat.
    """
    if p <= 0.5:
        w = p / 0.5  # weights: 0 -> squat, 1 -> peak
        deltas = [(1 - w) * ds + w * dp for ds, dp in zip(delta_squat, delta_peak)]
    else:
        w = (p - 0.5) / 0.5  # weights: 0 -> peak, 1 -> squat
        deltas = [(1 - w) * dp + w * ds for ds, dp in zip(delta_squat, delta_peak)]
    return deltas

def get_jump_offset(p):
    """
    Calculate a smooth vertical translation for the jump.
    At p=0 and p=1, jump offset = 0.
    At p=0.5, jump offset = -jump_height (i.e. moving upward).
    We use a sine profile.
    """
    return -jump_height * math.sin(math.pi * p)

def get_marker_positions(t):
    """
    Compute final screen positions (x, y) for all 15 markers at time t.
    """
    # Compute progress in cycle [0,1]
    p = (t % period) / period
    deltas = get_interpolated_deltas(p)
    jump_off = get_jump_offset(p)
    positions = []
    for (bx, by), dy in zip(base_skel, deltas):
        x = center_x + bx
        # Add base y position, delta adjustment, a global offset, and jump vertical translation.
        y = offset_y + by + dy + jump_off
        positions.append((int(x), int(y)))
    return positions

def main():
    start_time = time.time()
    running = True
    while running:
        # Event Handling
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        # Clear screen with black background
        screen.fill((0, 0, 0))

        # Compute current marker positions
        current_t = time.time() - start_time
        points = get_marker_positions(current_t)

        # Draw each marker as a small white circle (point-light)
        for point in points:
            pygame.draw.circle(screen, (255, 255, 255), point, 4)

        # Update the display
        pygame.display.flip()

        # Cap frame rate for smooth motion
        clock.tick(60)

    pygame.quit()
    sys.exit()

if __name__ == '__main__':
    main()
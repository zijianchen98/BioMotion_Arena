
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.interpolate import CubicSpline

def create_biological_motion_animation():
    """
    Generates and displays a point-light stimulus animation of a sad, 
    lightweight woman sitting down, matching the specified requirements.
    """

    # 1. SKELETON DEFINITION (FIXED BODY PROPORTIONS)
    # These values define the segment lengths of the point-light figure.
    SKELETON_GEOMETRY = {
        "spine_len": 28.0,
        "neck_to_head_len": 10.0,
        "shoulder_dist_from_neck": 11.0,
        "humerus_len": 15.0,
        "forearm_len": 13.0,
        "hip_dist_from_pelvis": 5.0,
        "femur_len": 22.0,
        "tibia_len": 20.0,
    }

    # 2. KEYFRAME DEFINITION (POSES OVER TIME)
    # This dictionary defines the core poses of the "sitting down" action.
    # The animation is generated by smoothly interpolating between these poses.
    # Angles are in degrees: 0=right, 90=up, 180=left, 270=down.
    keyframe_times = [0.0, 0.35, 0.7, 1.0]
    
    keyframes = {
        # Root of the skeleton (pelvis) position
        'pelvis_x': [0, 0, -10, -12],
        'pelvis_y': [-0, -12, -25, -25],

        # Torso and head angles to create a "sad" slumped posture
        'torso_angle': [95, 115, 135, 130],
        'head_angle_offset': [20, 25, 30, 25],

        # Right leg angles for sitting
        'r_hip_angle': [265, 225, 180, 180],
        'r_knee_angle_offset': [-5, -45, -90, -90],

        # Left leg angles for sitting
        'l_hip_angle': [275, 315, 360, 360],
        'l_knee_angle_offset': [5, 45, 90, 90],

        # Arm angles, moving from sides to rest on the lap
        'r_shoulder_angle': [280, 240, 185, 185],
        'r_elbow_angle_offset': [-10, -30, -50, -50],
        'l_shoulder_angle': [260, 300, 355, 355],
        'l_elbow_angle_offset': [10, 30, 50, 50],
    }

    # 3. CREATE INTERPOLATORS
    # Cubic splines are used to generate smooth, natural motion between keyframes.
    interpolators = {
        param: CubicSpline(keyframe_times, values)
        for param, values in keyframes.items()
    }

    # 4. FORWARD KINEMATICS CALCULATION
    def get_joint_coordinates(t):
        """
        Calculates the 15 joint positions for a given time t (from 0 to 1)
        using the interpolated parameters and skeleton geometry.
        """
        
        def to_vector(angle_deg, length):
            rad = np.deg2rad(angle_deg)
            return np.array([length * np.cos(rad), length * np.sin(rad)])

        params = {p: f(t) for p, f in interpolators.items()}
        coords = {}

        # Calculate torso chain: Pelvis -> Neck -> Head
        coords['pelvis'] = np.array([params['pelvis_x'], params['pelvis_y']])
        coords['neck'] = coords['pelvis'] + to_vector(params['torso_angle'], SKELETON_GEOMETRY['spine_len'])
        coords['head'] = coords['neck'] + to_vector(params['torso_angle'] + params['head_angle_offset'], SKELETON_GEOMETRY['neck_to_head_len'])
        
        # Calculate shoulders and hips based on torso/pelvis orientation
        torso_angle = params['torso_angle']
        coords['r_shoulder'] = coords['neck'] + to_vector(torso_angle - 90, SKELETON_GEOMETRY['shoulder_dist_from_neck'])
        coords['l_shoulder'] = coords['neck'] + to_vector(torso_angle + 90, SKELETON_GEOMETRY['shoulder_dist_from_neck'])
        coords['r_hip'] = coords['pelvis'] + to_vector(0, SKELETON_GEOMETRY['hip_dist_from_pelvis'])
        coords['l_hip'] = coords['pelvis'] + to_vector(180, SKELETON_GEOMETRY['hip_dist_from_pelvis'])

        # Calculate arm chains
        r_upper_arm_angle = params['r_shoulder_angle']
        l_upper_arm_angle = params['l_shoulder_angle']
        coords['r_elbow'] = coords['r_shoulder'] + to_vector(r_upper_arm_angle, SKELETON_GEOMETRY['humerus_len'])
        coords['l_elbow'] = coords['l_shoulder'] + to_vector(l_upper_arm_angle, SKELETON_GEOMETRY['humerus_len'])
        coords['r_wrist'] = coords['r_elbow'] + to_vector(r_upper_arm_angle + params['r_elbow_angle_offset'], SKELETON_GEOMETRY['forearm_len'])
        coords['l_wrist'] = coords['l_elbow'] + to_vector(l_upper_arm_angle + params['l_elbow_angle_offset'], SKELETON_GEOMETRY['forearm_len'])

        # Calculate leg chains
        r_thigh_angle = params['r_hip_angle']
        l_thigh_angle = params['l_hip_angle']
        coords['r_knee'] = coords['r_hip'] + to_vector(r_thigh_angle, SKELETON_GEOMETRY['femur_len'])
        coords['l_knee'] = coords['l_hip'] + to_vector(l_thigh_angle, SKELETON_GEOMETRY['femur_len'])
        coords['r_ankle'] = coords['r_knee'] + to_vector(r_thigh_angle + params['r_knee_angle_offset'], SKELETON_GEOMETRY['tibia_len'])
        coords['l_ankle'] = coords['l_knee'] + to_vector(l_thigh_angle + params['l_knee_angle_offset'], SKELETON_GEOMETRY['tibia_len'])

        point_order = [
            'head', 'neck', 'r_shoulder', 'l_shoulder', 'r_elbow', 'l_elbow',
            'r_wrist', 'l_wrist', 'pelvis', 'r_hip', 'l_hip', 'r_knee',
            'l_knee', 'r_ankle', 'l_ankle'
        ]
        return np.array([coords[p] for p in point_order])

    # 5. MATPLOTLIB ANIMATION SETUP
    fig, ax = plt.subplots(figsize=(5, 7))
    ax.set_facecolor('black')
    ax.set_xlim(-45, 45)
    ax.set_ylim(-55, 55)
    ax.set_aspect('equal', adjustable='box')
    ax.axis('off')  # Hide axes for a clean look
    fig.tight_layout(pad=0)

    initial_coords = get_joint_coordinates(0)
    scatter = ax.scatter(initial_coords[:, 0], initial_coords[:, 1], c='white', s=70)

    num_frames = 120
    def animate(frame):
        # t is the animation progress from 0.0 to 1.0
        t = frame / (num_frames - 1)
        coords = get_joint_coordinates(t)
        scatter.set_offsets(coords)
        return scatter,

    # Interval is the delay between frames in milliseconds.
    # A slightly larger interval creates a slower, more somber motion.
    anim = FuncAnimation(fig, animate, frames=num_frames, interval=50, blit=True)
    plt.show()


if __name__ == '__main__':
    create_biological_motion_animation()
